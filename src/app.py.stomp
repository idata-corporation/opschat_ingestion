import json
import os
import logging
from embeddings_util import EmbeddingsUtil
from activemq_util import ActiveMQ
import stomp
import time
host_name = os.getenv('HOSTNAME', 'unknown-host')

message_processed = 1

# Configure the embeddings utility
embeddings_util = EmbeddingsUtil(os.getenv("EMBEDDING_MODEL_LOCATION"))

# Configure logging
logging.basicConfig(
    level=logging.INFO,  # Adjust log level as needed (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    format=f"%(asctime)s [{host_name}] [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler()  # StreamHandler ensures logs are printed to stdout
    ]
)

def connect_and_subscribe(conn, user, password, embedding_queue, client_id):
    conn.connect(user, password, wait=True)
    conn.subscribe(destination=embedding_queue, id=client_id, ack='auto', headers={"activemq.prefetchSize":1})

class MyListener(stomp.ConnectionListener):
    def __init__(self, conn, user, password, embedding_queue, client_id, vector_store_queue):
        self.conn = conn
        self.user = user
        self.password = password
        self.embedding_queue = embedding_queue
        self.client_id = client_id
        self.vector_store_queue = vector_store_queue
    def on_error(self, frame):
        logging.error('received an error "%s"' % frame.body)

    def on_message(self, frame):
        logging.info('received a message "%s"' % frame.body)
        global message_processed  # Declare the global variable
        logging.info(f"Processing message: {message_processed}")
        modified_items = merge_embeddings(embeddings_util, eval(frame.body))

        # Write the items with merged embeddings to the vector store queue
        self.conn.send(self.vector_store_queue, json.dumps(modified_items))
        message_processed += 1  # Increment the global counter

    def on_disconnected(self):
        logging.info('disconnected')
        connect_and_subscribe(self.conn, self.user, self.password, self.embedding_queue, self.client_id)

def merge_embeddings(embeddings_util, items):
    texts = []

    # Get the texts from the messages
    for item in items:
        text = item['text']
        texts.append(text)

    # Get the embeddings and merge back in
    embeddings = embeddings_util.get(texts)
    for item, embedding in zip(items, embeddings):
        item["embeddings"] = embedding
    return items
 
if __name__ == "__main__":
    activemq_host = os.getenv("ACTIVEMQ_HOST")
    activemq_port = os.getenv("ACTIVEMQ_PORT") 
    embedding_queue = os.getenv("EMBEDDING_QUEUE") # + "/" + host_name
    vector_store_queue = os.getenv("VECTOR_STORE_QUEUE")
    client_id = os.getenv("MQ_CLIENT_ID") or 1
    headers = {"activemq.prefetchSize":1}

    logging.info(f"{activemq_host}, {activemq_port}, {embedding_queue}, {vector_store_queue}, {client_id}, {headers}")
    # Connect to ActiveMQ
    #activemq = ActiveMQ(host=activemq_host, port=int(activemq_port), username='artemis', password='artemis')
    #logging.info(f"Listening for messages from the queue: {embedding_queue}...")
    conn = None
    while True:
        try:
            if conn is None or not conn.is_connected():
                print('Attempting to connect...')
                conn = stomp.Connection([(activemq_host, int(activemq_port))])
                conn.set_listener('', MyListener(conn, 'artemis', 'artemis', embedding_queue, client_id, vector_store_queue))
                connect_and_subscribe(conn, 'artemis', 'artemis', client_id, headers)
                logging.info('Connected to the server...')


        except stomp.exception.ConnectFailedException:
            print('Connection failed. Retrying in 5 seconds...')
            time.sleep(5)

        except Exception as e:
            print(f'An error occurred: {e}')
            if conn is not None:
                conn.disconnect()
            time.sleep(1)
